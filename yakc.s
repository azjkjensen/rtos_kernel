; Generated by c86 (BYU-NASM) 5.1 (beta) from yakc.i
	CPU	8086
	ALIGN	2
	jmp	main	; Jump to program start
	ALIGN	2
YKCtxSwCount:
	DW	0
YKIdleCount:
	DW	0
YKISRCallDepth:
	DW	0
YKTickNum:
	DW	1
currentTask:
	DW	0
saveContextTask:
	DW	0
running:
	DB	0
	ALIGN	2
TCBi:
	DW	0
semi:
	DW	0
Qi:
	DW	0
eventIndex:
	DW	0
	ALIGN	2
YKInitialize:
	; >>>>> Line:	50
	; >>>>> void YKInitialize(){ 
	jmp	L_yakc_1
L_yakc_2:
	; >>>>> Line:	51
	; >>>>> YKEnterMutex(); 
	call	YKEnterMutex
	; >>>>> Line:	54
	; >>>>> YKNewTask(YKIdleTask,(void*)&YKIdleTasks[256], 100); 
	mov	al, 100
	push	ax
	mov	ax, (YKIdleTasks+512)
	push	ax
	mov	ax, YKIdleTask
	push	ax
	call	YKNewTask
	add	sp, 6
	mov	sp, bp
	pop	bp
	ret
L_yakc_1:
	push	bp
	mov	bp, sp
	jmp	L_yakc_2
	ALIGN	2
YKIdleTask:
	; >>>>> Line:	61
	; >>>>> void YKIdleTask(void){ 
	jmp	L_yakc_4
L_yakc_5:
	; >>>>> Line:	63
	; >>>>> while(1){ 
	jmp	L_yakc_7
L_yakc_6:
	; >>>>> Line:	66
	; >>>>> ackPointer[10] 
	call	YKEnterMutex
	; >>>>> Line:	67
	; >>>>> YKIdleCount++; 
	inc	word [YKIdleCount]
	; >>>>> Line:	69
	; >>>>> YKExitMutex(); 
	call	YKExitMutex
L_yakc_7:
	jmp	L_yakc_6
L_yakc_8:
	mov	sp, bp
	pop	bp
	ret
L_yakc_4:
	push	bp
	mov	bp, sp
	jmp	L_yakc_5
	ALIGN	2
YKNewTask:
	; >>>>> Line:	73
	; >>>>> void YKNewTask(void (*task)(void), void* taskStack, unsigned char priority){ 
	jmp	L_yakc_10
L_yakc_11:
	; >>>>> Line:	77
	; >>>>> YKEnterMutex(); 
	call	YKEnterMutex
	; >>>>> Line:	78
	; >>>>> YKTCBs[TCBi].state = 1; 
	mov	ax, word [TCBi]
	mov	cx, 18
	imul	cx
	add	ax, YKTCBs
	mov	si, ax
	add	si, 2
	mov	byte [si], 1
	; >>>>> Line:	79
	; >>>>> YKTCBs[TCBi].priority = priority; 
	mov	ax, word [TCBi]
	mov	cx, 18
	imul	cx
	add	ax, YKTCBs
	mov	si, ax
	add	si, 3
	mov	al, byte [bp+8]
	mov	byte [si], al
	; >>>>> Line:	80
	; >>>>> YKTCBs[TCBi].delay = 0; 
	mov	ax, word [TCBi]
	mov	cx, 18
	imul	cx
	add	ax, YKTCBs
	mov	si, ax
	add	si, 6
	mov	word [si], 0
	; >>>>> Line:	82
	; >>>>> newStackPointer = (unsigned*)taskStack - 11; 
	mov	ax, word [bp+6]
	sub	ax, 22
	mov	word [bp-2], ax
	; >>>>> Line:	84
	; >>>>> for(i = 0; i < 8; i++){ 
	mov	word [bp-4], 0
	jmp	L_yakc_13
L_yakc_12:
	; >>>>> Line:	85
	; >>>>> newStackPointer[i] = 0; 
	mov	ax, word [bp-4]
	shl	ax, 1
	mov	si, ax
	add	si, word [bp-2]
	mov	word [si], 0
L_yakc_15:
	inc	word [bp-4]
L_yakc_13:
	cmp	word [bp-4], 8
	jl	L_yakc_12
L_yakc_14:
	; >>>>> Line:	88
	; >>>>> newStackPointer[8] = (unsigned) task; 
	mov	si, word [bp-2]
	add	si, 16
	mov	ax, word [bp+4]
	mov	word [si], ax
	; >>>>> Line:	89
	; >>>>> newStackPointer[9] = 0; 
	mov	si, word [bp-2]
	add	si, 18
	mov	word [si], 0
	; >>>>> Line:	90
	; >>>>> newStackPointer[10] 
	mov	si, word [bp-2]
	add	si, 20
	mov	word [si], 512
	; >>>>> Line:	93
	; >>>>> YKTCBs[TCBi].stackPtr = newStackPointer - 1; 
	mov	ax, word [bp-2]
	sub	ax, 2
	push	ax
	mov	ax, word [TCBi]
	mov	cx, 18
	imul	cx
	mov	dx, ax
	mov	si, dx
	add	si, YKTCBs
	pop	ax
	mov	word [si], ax
	; >>>>> Line:	95
	; >>>>> if(TCBi == 0){ 
	mov	ax, word [TCBi]
	test	ax, ax
	jne	L_yakc_16
	; >>>>> Line:	96
	; >>>>> readyRoot = &YKTCBs[TCBi]; 
	mov	ax, word [TCBi]
	mov	cx, 18
	imul	cx
	add	ax, YKTCBs
	mov	word [readyRoot], ax
	; >>>>> Line:	97
	; >>>>> YKTCBs[TCBi].next = 0; 
	mov	ax, word [TCBi]
	mov	cx, 18
	imul	cx
	add	ax, YKTCBs
	mov	si, ax
	add	si, 4
	mov	word [si], 0
	jmp	L_yakc_17
L_yakc_16:
	; >>>>> Line:	99
	; >>>>> if(priority < readyRoot->priority){ 
	mov	si, word [readyRoot]
	add	si, 3
	mov	al, byte [bp+8]
	cmp	al, byte [si]
	jae	L_yakc_18
	; >>>>> Line:	100
	; >>>>> YKTCBs[TCBi].next = readyRoot; 
	mov	ax, word [TCBi]
	mov	cx, 18
	imul	cx
	add	ax, YKTCBs
	mov	si, ax
	add	si, 4
	mov	ax, word [readyRoot]
	mov	word [si], ax
	; >>>>> Line:	101
	; >>>>> readyRoot = &YKTCBs[TCBi]; 
	mov	ax, word [TCBi]
	mov	cx, 18
	imul	cx
	add	ax, YKTCBs
	mov	word [readyRoot], ax
	jmp	L_yakc_19
L_yakc_18:
	; >>>>> Line:	104
	; >>>>> browser = readyRoot; 
	mov	ax, word [readyRoot]
	mov	word [bp-6], ax
	; >>>>> Line:	106
	; >>>>> while(browser){ 
	jmp	L_yakc_21
L_yakc_20:
	; >>>>> Line:	107
	; >>>>> if(priority < browser->next->priority){ 
	mov	si, word [bp-6]
	add	si, 4
	mov	si, word [si]
	add	si, 3
	mov	al, byte [bp+8]
	cmp	al, byte [si]
	jae	L_yakc_23
	; >>>>> Line:	108
	; >>>>> YKTCBs[TCBi].next = browser->next; 
	mov	si, word [bp-6]
	add	si, 4
	mov	ax, word [TCBi]
	mov	cx, 18
	imul	cx
	add	ax, YKTCBs
	mov	di, ax
	add	di, 4
	mov	ax, word [si]
	mov	word [di], ax
	; >>>>> Line:	109
	; >>>>> oRun  
	mov	ax, word [TCBi]
	mov	cx, 18
	imul	cx
	add	ax, YKTCBs
	mov	si, word [bp-6]
	add	si, 4
	mov	word [si], ax
	; >>>>> Line:	110
	; >>>>> break; 
	jmp	L_yakc_22
L_yakc_23:
	; >>>>> Line:	112
	; >>>>> browser = browser->next; 
	mov	si, word [bp-6]
	add	si, 4
	mov	ax, word [si]
	mov	word [bp-6], ax
L_yakc_21:
	mov	ax, word [bp-6]
	test	ax, ax
	jne	L_yakc_20
L_yakc_22:
L_yakc_19:
L_yakc_17:
	; >>>>> Line:	117
	; >>>>> TCBi++; 
	inc	word [TCBi]
	; >>>>> Line:	118
	; >>>>> if(running){ 
	mov	al, byte [running]
	test	al, al
	je	L_yakc_24
	; >>>>> Line:	119
	; >>>>> YKScheduler(1); 
	mov	al, 1
	push	ax
	call	YKScheduler
	add	sp, 2
L_yakc_24:
	mov	sp, bp
	pop	bp
	ret
L_yakc_10:
	push	bp
	mov	bp, sp
	sub	sp, 6
	jmp	L_yakc_11
	ALIGN	2
YKScheduler:
	; >>>>> Line:	123
	; >>>>> void YKScheduler(unsigned char saveContext){ 
	jmp	L_yakc_26
L_yakc_27:
	; >>>>> Line:	126
	; >>>>> browser = readyRoot; 
	mov	ax, word [readyRoot]
	mov	word [bp-2], ax
	; >>>>> Line:	127
	; >>>>> YKEnterMutex(); 
	call	YKEnterMutex
	; >>>>> Line:	128
	; >>>>> while(browser){ 
	jmp	L_yakc_29
L_yakc_28:
	; >>>>> Line:	129
	; >>>>> if(browser->state == 1){ 
	mov	si, word [bp-2]
	add	si, 2
	cmp	byte [si], 1
	jne	L_yakc_31
	; >>>>> Line:	130
	; >>>>> taskToRun = browser; 
	mov	ax, word [bp-2]
	mov	word [taskToRun], ax
	; >>>>> Line:	131
	; >>>>> break; 
	jmp	L_yakc_30
L_yakc_31:
	; >>>>> Line:	133
	; >>>>> browser = browser->next; 
	mov	si, word [bp-2]
	add	si, 4
	mov	ax, word [si]
	mov	word [bp-2], ax
L_yakc_29:
	mov	ax, word [bp-2]
	test	ax, ax
	jne	L_yakc_28
L_yakc_30:
	; >>>>> Line:	136
	; >>>>> if(taskToRun  
	mov	ax, word [currentTask]
	cmp	ax, word [taskToRun]
	je	L_yakc_32
	; >>>>> Line:	138
	; >>>>> saveContextTask = currentTask; 
	mov	ax, word [currentTask]
	mov	word [saveContextTask], ax
	; >>>>> Line:	139
	; >>>>> currentTask = taskToRun; 
	mov	ax, word [taskToRun]
	mov	word [currentTask], ax
	; >>>>> Line:	142
	; >>>>> YKCtxSwCount++; 
	inc	word [YKCtxSwCount]
	; >>>>> Line:	143
	; >>>>> YKDispatcher(saveContext); 
	push	word [bp+4]
	call	YKDispatcher
	add	sp, 2
L_yakc_32:
	mov	sp, bp
	pop	bp
	ret
L_yakc_26:
	push	bp
	mov	bp, sp
	push	cx
	jmp	L_yakc_27
	ALIGN	2
YKRun:
	; >>>>> Line:	148
	; >>>>> void YKRun() { 
	jmp	L_yakc_34
L_yakc_35:
	; >>>>> Line:	150
	; >>>>> running = 1; 
	mov	byte [running], 1
	; >>>>> Line:	151
	; >>>>> YKScheduler(0); 
	xor	al, al
	push	ax
	call	YKScheduler
	add	sp, 2
	mov	sp, bp
	pop	bp
	ret
L_yakc_34:
	push	bp
	mov	bp, sp
	jmp	L_yakc_35
	ALIGN	2
YKDelayTask:
	; >>>>> Line:	154
	; >>>>> void YKDelayTask(unsigned count){ 
	jmp	L_yakc_37
L_yakc_38:
	; >>>>> Line:	156
	; >>>>> YKEnterMutex(); 
	call	YKEnterMutex
	; >>>>> Line:	158
	; >>>>> if(!count){ 
	mov	ax, word [bp+4]
	test	ax, ax
	jne	L_yakc_39
	; >>>>> Line:	160
	; >>>>> return; 
	jmp	L_yakc_40
	jmp	L_yakc_41
L_yakc_39:
	; >>>>> Line:	164
	; >>>>> currentTask->delay = count; 
	mov	si, word [currentTask]
	add	si, 6
	mov	ax, word [bp+4]
	mov	word [si], ax
	; >>>>> Line:	165
	; >>>>> currentTask->state = 0; 
	mov	si, word [currentTask]
	add	si, 2
	mov	byte [si], 0
	; >>>>> Line:	167
	; >>>>> YKScheduler(1); 
	mov	al, 1
	push	ax
	call	YKScheduler
	add	sp, 2
	; >>>>> Line:	168
	; >>>>> YKExitMutex(); 
	call	YKExitMutex
L_yakc_41:
L_yakc_40:
	mov	sp, bp
	pop	bp
	ret
L_yakc_37:
	push	bp
	mov	bp, sp
	jmp	L_yakc_38
	ALIGN	2
YKEnterISR:
	; >>>>> Line:	173
	; >>>>> void YKEnterISR(void){ 
	jmp	L_yakc_43
L_yakc_44:
	; >>>>> Line:	175
	; >>>>> YKISRCallDepth++; 
	inc	word [YKISRCallDepth]
	mov	sp, bp
	pop	bp
	ret
L_yakc_43:
	push	bp
	mov	bp, sp
	jmp	L_yakc_44
	ALIGN	2
YKExitISR:
	; >>>>> Line:	178
	; >>>>> < 0){ 
	jmp	L_yakc_46
L_yakc_47:
	; >>>>> Line:	179
	; >>>>> YKISRCallDepth--; 
	dec	word [YKISRCallDepth]
	; >>>>> Line:	182
	; >>>>> if(!YKISRCallDepth){ 
	mov	ax, word [YKISRCallDepth]
	test	ax, ax
	jne	L_yakc_48
	; >>>>> Line:	183
	; >>>>> YKScheduler(1); 
	mov	al, 1
	push	ax
	call	YKScheduler
	add	sp, 2
	; >>>>> Line:	184
	; >>>>> YKExitMutex(); 
	call	YKExitMutex
L_yakc_48:
	mov	sp, bp
	pop	bp
	ret
L_yakc_46:
	push	bp
	mov	bp, sp
	jmp	L_yakc_47
	ALIGN	2
YKTickHandler:
	; >>>>> Line:	188
	; >>>>> void YKTickHandler(void){ 
	jmp	L_yakc_50
L_yakc_51:
	; >>>>> Line:	192
	; >>>>> YKTickNum++; 
	inc	word [YKTickNum]
	; >>>>> Line:	194
	; >>>>> browser = readyRoot; 
	mov	ax, word [readyRoot]
	mov	word [bp-2], ax
	; >>>>> Line:	195
	; >>>>> while(browser){ 
	jmp	L_yakc_53
L_yakc_52:
	; >>>>> Line:	196
	; >>>>> if(browser->state == 0){ 
	mov	si, word [bp-2]
	add	si, 2
	mov	al, byte [si]
	test	al, al
	jne	L_yakc_55
	; >>>>> Line:	197
	; >>>>> browser->delay--; 
	mov	si, word [bp-2]
	add	si, 6
	dec	word [si]
	; >>>>> Line:	203
	; >>>>> if(!(browser->delay)){ 
	mov	si, word [bp-2]
	add	si, 6
	mov	ax, word [si]
	test	ax, ax
	jne	L_yakc_56
	; >>>>> Line:	204
	; >>>>> browser->state = 1; 
	mov	si, word [bp-2]
	add	si, 2
	mov	byte [si], 1
L_yakc_56:
L_yakc_55:
	; >>>>> Line:	209
	; >>>>> browser = browser->next; 
	mov	si, word [bp-2]
	add	si, 4
	mov	ax, word [si]
	mov	word [bp-2], ax
L_yakc_53:
	mov	ax, word [bp-2]
	test	ax, ax
	jne	L_yakc_52
L_yakc_54:
	mov	sp, bp
	pop	bp
	ret
L_yakc_50:
	push	bp
	mov	bp, sp
	push	cx
	jmp	L_yakc_51
	ALIGN	2
YKSemCreate:
	; >>>>> Line:	213
	; >>>>> YKSem* YKSemCreate(int val){ 
	jmp	L_yakc_58
L_yakc_59:
	; >>>>> Line:	215
	; >>>>> if(val < 0){ 
	cmp	word [bp+4], 0
	jge	L_yakc_60
	; >>>>> Line:	216
	; >>>>> return  
	xor	ax, ax
	jmp	L_yakc_61
L_yakc_60:
	; >>>>> Line:	219
	; >>>>> newSem = &YKSEMS[semi]; 
	mov	ax, word [semi]
	shl	ax, 1
	add	ax, YKSEMS
	mov	word [bp-2], ax
	; >>>>> Line:	220
	; >>>>> *newSem = val; 
	mov	si, word [bp-2]
	mov	ax, word [bp+4]
	mov	word [si], ax
	; >>>>> Line:	221
	; >>>>> semi++; 
	inc	word [semi]
	; >>>>> Line:	222
	; >>>>> return newSem; 
	mov	ax, word [bp-2]
L_yakc_61:
	mov	sp, bp
	pop	bp
	ret
L_yakc_58:
	push	bp
	mov	bp, sp
	push	cx
	jmp	L_yakc_59
	ALIGN	2
YKSemPend:
	; >>>>> Line:	225
	; >>>>> void YKSemPend(YKSem* sem){ 
	jmp	L_yakc_63
L_yakc_64:
	; >>>>> Line:	226
	; >>>>> YKEnterMutex(); 
	call	YKEnterMutex
	; >>>>> Line:	227
	; >>>>> if(!(*sem)){ 
	mov	si, word [bp+4]
	mov	ax, word [si]
	test	ax, ax
	jne	L_yakc_65
	; >>>>> Line:	228
	; >>>>> currentTask->state = 2; 
	mov	si, word [currentTask]
	add	si, 2
	mov	byte [si], 2
	; >>>>> Line:	229
	; >>>>> currentTask->semBlock = sem; 
	mov	si, word [currentTask]
	add	si, 8
	mov	ax, word [bp+4]
	mov	word [si], ax
	; >>>>> Line:	230
	; >>>>> YKScheduler(1); 
	mov	al, 1
	push	ax
	call	YKScheduler
	add	sp, 2
L_yakc_65:
	; >>>>> Line:	232
	; >>>>> (*sem)--; 
	mov	si, word [bp+4]
	dec	word [si]
	; >>>>> Line:	233
	; >>>>> YKExitMutex(); 
	call	YKExitMutex
	mov	sp, bp
	pop	bp
	ret
L_yakc_63:
	push	bp
	mov	bp, sp
	jmp	L_yakc_64
	ALIGN	2
YKSemPost:
	; >>>>> Line:	237
	; >>>>> void YKSemPost(YKSem* sem){ 
	jmp	L_yakc_67
L_yakc_68:
	; >>>>> Line:	240
	; >>>>> YKEnterMutex(); 
	call	YKEnterMutex
	; >>>>> Line:	241
	; >>>>> (*sem)++; 
	mov	si, word [bp+4]
	inc	word [si]
	; >>>>> Line:	242
	; >>>>> browser = readyRoot; 
	mov	ax, word [readyRoot]
	mov	word [bp-2], ax
	; >>>>> Line:	244
	; >>>>> while(browser){ 
	jmp	L_yakc_70
L_yakc_69:
	; >>>>> Line:	245
	; >>>>> if(browser->state == 2 && browser->semBlock == sem){ 
	mov	si, word [bp-2]
	add	si, 2
	cmp	byte [si], 2
	jne	L_yakc_72
	mov	si, word [bp-2]
	add	si, 8
	mov	ax, word [bp+4]
	cmp	ax, word [si]
	jne	L_yakc_72
	; >>>>> Line:	246
	; >>>>> browser-> 
	mov	si, word [bp-2]
	add	si, 2
	mov	byte [si], 1
	; >>>>> Line:	247
	; >>>>> browser->semBlock = 0; 
	mov	si, word [bp-2]
	add	si, 8
	mov	word [si], 0
	; >>>>> Line:	248
	; >>>>> break; 
	jmp	L_yakc_71
L_yakc_72:
	; >>>>> Line:	250
	; >>>>> browser = browser->next; 
	mov	si, word [bp-2]
	add	si, 4
	mov	ax, word [si]
	mov	word [bp-2], ax
L_yakc_70:
	mov	ax, word [bp-2]
	test	ax, ax
	jne	L_yakc_69
L_yakc_71:
	; >>>>> Line:	253
	; >>>>> if(YKISRCallDepth == 0){ 
	mov	ax, word [YKISRCallDepth]
	test	ax, ax
	jne	L_yakc_73
	; >>>>> Line:	254
	; >>>>> YKScheduler(1); 
	mov	al, 1
	push	ax
	call	YKScheduler
	add	sp, 2
L_yakc_73:
	; >>>>> Line:	256
	; >>>>> YKExitMutex(); 
	call	YKExitMutex
	mov	sp, bp
	pop	bp
	ret
L_yakc_67:
	push	bp
	mov	bp, sp
	push	cx
	jmp	L_yakc_68
	ALIGN	2
YKQCreate:
	; >>>>> Line:	259
	; >>>>> YKQ* YKQCreate(void** start, unsigned size){ 
	jmp	L_yakc_75
L_yakc_76:
	; >>>>> Line:	260
	; >>>>> YKQS[Qi].length = size; 
	mov	ax, word [Qi]
	mov	cx, 10
	imul	cx
	add	ax, YKQS
	mov	si, ax
	add	si, 2
	mov	ax, word [bp+6]
	mov	word [si], ax
	; >>>>> Line:	261
	; >>>>> YKQS[Qi].queueAddress = start; 
	mov	ax, word [Qi]
	mov	cx, 10
	imul	cx
	mov	si, ax
	add	si, YKQS
	mov	ax, word [bp+4]
	mov	word [si], ax
	; >>>>> Line:	262
	; >>>>> YKQS[Qi].nextEmpty = start; 
	mov	ax, word [Qi]
	mov	cx, 10
	imul	cx
	add	ax, YKQS
	mov	si, ax
	add	si, 4
	mov	ax, word [bp+4]
	mov	word [si], ax
	; >>>>> Line:	263
	; >>>>> YKQS[Qi].nextRemove = start; 
	mov	ax, word [Qi]
	mov	cx, 10
	imul	cx
	add	ax, YKQS
	mov	si, ax
	add	si, 6
	mov	ax, word [bp+4]
	mov	word [si], ax
	; >>>>> Line:	264
	; >>>>> YKQS[Qi].state = 0; 
	mov	ax, word [Qi]
	mov	cx, 10
	imul	cx
	add	ax, YKQS
	mov	si, ax
	add	si, 8
	mov	word [si], 0
	; >>>>> Line:	266
	; >>>>> Qi++; 
	inc	word [Qi]
	; >>>>> Line:	268
	; >>>>> return &YKQS[Qi - 1]; 
	mov	ax, word [Qi]
	dec	ax
	mov	cx, 10
	imul	cx
	add	ax, YKQS
L_yakc_77:
	mov	sp, bp
	pop	bp
	ret
L_yakc_75:
	push	bp
	mov	bp, sp
	jmp	L_yakc_76
	ALIGN	2
YKQPend:
	; >>>>> Line:	271
	; >>>>> void* YKQPend(YKQ* q){ 
	jmp	L_yakc_79
L_yakc_80:
	; >>>>> Line:	273
	; >>>>> YKEnterMutex(); 
	call	YKEnterMutex
	; >>>>> Line:	274
	; >>>>> if(q->stat 
	mov	si, word [bp+4]
	add	si, 8
	mov	ax, word [si]
	test	ax, ax
	jne	L_yakc_81
	; >>>>> Line:	275
	; >>>>> currentTask->state = 3; 
	mov	si, word [currentTask]
	add	si, 2
	mov	byte [si], 3
	; >>>>> Line:	276
	; >>>>> currentTask->qBlock = q; 
	mov	si, word [currentTask]
	add	si, 10
	mov	ax, word [bp+4]
	mov	word [si], ax
	; >>>>> Line:	277
	; >>>>> YKScheduler(1); 
	mov	al, 1
	push	ax
	call	YKScheduler
	add	sp, 2
L_yakc_81:
	; >>>>> Line:	280
	; >>>>> t = (void*)* q->nextRemove; 
	mov	si, word [bp+4]
	add	si, 6
	mov	si, word [si]
	mov	ax, word [si]
	mov	word [bp-2], ax
	; >>>>> Line:	281
	; >>>>> q->nextRemove++; 
	mov	si, word [bp+4]
	add	si, 6
	add	word [si], 2
	; >>>>> Line:	283
	; >>>>> if(q->nextRemove == q->queueAddress + q->length){ 
	mov	si, word [bp+4]
	add	si, 2
	mov	ax, word [si]
	shl	ax, 1
	mov	si, word [bp+4]
	add	ax, word [si]
	add	si, 6
	mov	dx, word [si]
	cmp	dx, ax
	jne	L_yakc_82
	; >>>>> Line:	284
	; >>>>> q->nextRemove = q->queueAddress; 
	mov	si, word [bp+4]
	mov	di, word [bp+4]
	add	di, 6
	mov	ax, word [si]
	mov	word [di], ax
L_yakc_82:
	; >>>>> Line:	287
	; >>>>> if(q->state == 1){ 
	mov	si, word [bp+4]
	add	si, 8
	cmp	word [si], 1
	jne	L_yakc_83
	; >>>>> Line:	288
	; >>>>> q->state = 2; 
	mov	si, word [bp+4]
	add	si, 8
	mov	word [si], 2
	jmp	L_yakc_84
L_yakc_83:
	; >>>>> Line:	289
	; >>>>> } else if(q->nextRemove == q->nextEmpty){ 
	mov	si, word [bp+4]
	add	si, 6
	mov	di, word [bp+4]
	add	di, 4
	mov	ax, word [di]
	cmp	ax, word [si]
	jne	L_yakc_85
	; >>>>> Line:	290
	; >>>>> q->state = 0; 
	mov	si, word [bp+4]
	add	si, 8
	mov	word [si], 0
L_yakc_85:
L_yakc_84:
	; >>>>> Line:	292
	; >>>>> YKExitMutex(); 
	call	YKExitMutex
	; >>>>> Line:	293
	; >>>>> return t; 
	mov	ax, word [bp-2]
L_yakc_86:
	mov	sp, bp
	pop	bp
	ret
L_yakc_79:
	push	bp
	mov	bp, sp
	push	cx
	jmp	L_yakc_80
	ALIGN	2
YKQPost:
	; >>>>> Line:	296
	; >>>>> int YKQPost(YKQ* q, void* msg){ 
	jmp	L_yakc_88
L_yakc_89:
	; >>>>> Line:	298
	; >>>>> YKEnterMutex(); 
	call	YKEnterMutex
	; >>>>> Line:	300
	; >>>>> if(q->state == 
	mov	si, word [bp+4]
	add	si, 8
	cmp	word [si], 1
	jne	L_yakc_90
	; >>>>> Line:	301
	; >>>>> YKExitMutex(); 
	call	YKExitMutex
	; >>>>> Line:	302
	; >>>>> return 0; 
	xor	ax, ax
	jmp	L_yakc_91
L_yakc_90:
	; >>>>> Line:	305
	; >>>>> *(q->nextEmpty) = msg; 
	mov	si, word [bp+4]
	add	si, 4
	mov	si, word [si]
	mov	ax, word [bp+6]
	mov	word [si], ax
	; >>>>> Line:	306
	; >>>>> q->nextEmpty++; 
	mov	si, word [bp+4]
	add	si, 4
	add	word [si], 2
	; >>>>> Line:	308
	; >>>>> if(q->nextEmpty == q->queueAddress + q->length){ 
	mov	si, word [bp+4]
	add	si, 2
	mov	ax, word [si]
	shl	ax, 1
	mov	si, word [bp+4]
	add	ax, word [si]
	add	si, 4
	mov	dx, word [si]
	cmp	dx, ax
	jne	L_yakc_92
	; >>>>> Line:	309
	; >>>>> q->nextEmpty = q->queueAddress; 
	mov	si, word [bp+4]
	mov	di, word [bp+4]
	add	di, 4
	mov	ax, word [si]
	mov	word [di], ax
L_yakc_92:
	; >>>>> Line:	312
	; >>>>> if(q->state == 0){ 
	mov	si, word [bp+4]
	add	si, 8
	mov	ax, word [si]
	test	ax, ax
	jne	L_yakc_93
	; >>>>> Line:	313
	; >>>>> q->state = 2; 
	mov	si, word [bp+4]
	add	si, 8
	mov	word [si], 2
	jmp	L_yakc_94
L_yakc_93:
	; >>>>> Line:	314
	; >>>>> } else if(q->nextRemove == q->nextEmpty){ 
	mov	si, word [bp+4]
	add	si, 6
	mov	di, word [bp+4]
	add	di, 4
	mov	ax, word [di]
	cmp	ax, word [si]
	jne	L_yakc_95
	; >>>>> Line:	315
	; >>>>> q->state = 1; 
	mov	si, word [bp+4]
	add	si, 8
	mov	word [si], 1
L_yakc_95:
L_yakc_94:
	; >>>>> Line:	317
	; >>>>> browser = readyRoot; 
	mov	ax, word [readyRoot]
	mov	word [bp-2], ax
	; >>>>> Line:	319
	; >>>>> while(browser){ 
	jmp	L_yakc_97
L_yakc_96:
	; >>>>> Line:	320
	; >>>>> if(browser->state == 3){ 
	mov	si, word [bp-2]
	add	si, 2
	cmp	byte [si], 3
	jne	L_yakc_99
	; >>>>> Line:	321
	; >>>>> if(browser->qBlock == q){ 
	mov	si, word [bp-2]
	add	si, 10
	mov	ax, word [bp+4]
	cmp	ax, word [si]
	jne	L_yakc_100
	; >>>>> Line:	322
	; >>>>> browser->state = 1; 
	mov	si, word [bp-2]
	add	si, 2
	mov	byte [si], 1
	; >>>>> Line:	323
	; >>>>> browser->qBlock = 0; 
	mov	si, word [bp-2]
	add	si, 10
	mov	word [si], 0
	; >>>>> Line:	324
	; >>>>> f( 
	jmp	L_yakc_98
L_yakc_100:
L_yakc_99:
	; >>>>> Line:	327
	; >>>>> browser = browser->next; 
	mov	si, word [bp-2]
	add	si, 4
	mov	ax, word [si]
	mov	word [bp-2], ax
	; >>>>> Line:	328
	; >>>>> YKExitMutex(); 
	call	YKExitMutex
L_yakc_97:
	mov	ax, word [bp-2]
	test	ax, ax
	jne	L_yakc_96
L_yakc_98:
	; >>>>> Line:	331
	; >>>>> if(YKISRCallDepth == 0){ 
	mov	ax, word [YKISRCallDepth]
	test	ax, ax
	jne	L_yakc_101
	; >>>>> Line:	332
	; >>>>> YKScheduler(1); 
	mov	al, 1
	push	ax
	call	YKScheduler
	add	sp, 2
L_yakc_101:
	; >>>>> Line:	335
	; >>>>> YKExitMutex(); 
	call	YKExitMutex
	; >>>>> Line:	336
	; >>>>> return 1; 
	mov	ax, 1
L_yakc_91:
	mov	sp, bp
	pop	bp
	ret
L_yakc_88:
	push	bp
	mov	bp, sp
	push	cx
	jmp	L_yakc_89
	ALIGN	2
YKEventCreate:
	; >>>>> Line:	348
	; >>>>> YKEVENT *YKEventCreate(unsigned initialValue) { 
	jmp	L_yakc_103
L_yakc_104:
	; >>>>> Line:	349
	; >>>>> YKEvents[eventIndex].flag = initialValue; 
	mov	ax, word [eventIndex]
	shl	ax, 1
	mov	si, ax
	add	si, YKEvents
	mov	ax, word [bp+4]
	mov	word [si], ax
	; >>>>> Line:	350
	; >>>>> eventIndex++; 
	inc	word [eventIndex]
	; >>>>> Line:	352
	; >>>>> return &YKEvents[eventIndex-1]; 
	mov	ax, word [eventIndex]
	dec	ax
	shl	ax, 1
	add	ax, YKEvents
L_yakc_105:
	mov	sp, bp
	pop	bp
	ret
L_yakc_103:
	push	bp
	mov	bp, sp
	jmp	L_yakc_104
	ALIGN	2
YKEventPend:
	; >>>>> Line:	367
	; >>>>> unsigned YKEventPend(YKEVENT *event, unsigned eventMask, int waitMode) { 
	jmp	L_yakc_107
L_yakc_108:
	; >>>>> Line:	368
	; >>>>> YKEnterMutex(); 
	call	YKEnterMutex
	; >>>>> Line:	370
	; >>>>> if(waitMode == 2){ 
	cmp	word [bp+8], 2
	jne	L_yakc_109
	; >>>>> Line:	371
	; >>>>> if( 
	mov	si, word [bp+4]
	mov	ax, word [bp+6]
	cmp	ax, word [si]
	jne	L_yakc_110
	; >>>>> Line:	372
	; >>>>> return event->flag; 
	mov	ax, word [si]
	jmp	L_yakc_111
L_yakc_110:
	jmp	L_yakc_112
L_yakc_109:
	; >>>>> Line:	375
	; >>>>> else if(waitMode == 1){ 
	cmp	word [bp+8], 1
	jne	L_yakc_113
	; >>>>> Line:	376
	; >>>>> if(event->flag & eventMask){ 
	mov	si, word [bp+4]
	mov	ax, word [si]
	and	ax, word [bp+6]
	je	L_yakc_114
	; >>>>> Line:	377
	; >>>>> return event->flag; 
	mov	ax, word [si]
	jmp	L_yakc_111
L_yakc_114:
L_yakc_113:
L_yakc_112:
	; >>>>> Line:	381
	; >>>>> currentTask->event = event; 
	mov	si, word [currentTask]
	add	si, 12
	mov	ax, word [bp+4]
	mov	word [si], ax
	; >>>>> Line:	382
	; >>>>> currentTask->mask = eventMask; 
	mov	si, word [currentTask]
	add	si, 16
	mov	ax, word [bp+6]
	mov	word [si], ax
	; >>>>> Line:	383
	; >>>>> currentTask->mode = waitMode; 
	mov	si, word [currentTask]
	add	si, 14
	mov	ax, word [bp+8]
	mov	word [si], ax
	; >>>>> Line:	384
	; >>>>> currentTask->state = 5; 
	mov	si, word [currentTask]
	add	si, 2
	mov	byte [si], 5
	; >>>>> Line:	386
	; >>>>> YKScheduler(1); 
	mov	al, 1
	push	ax
	call	YKScheduler
	add	sp, 2
	; >>>>> Line:	388
	; >>>>> YKExitMutex(); 
	call	YKExitMutex
	; >>>>> Line:	389
	; >>>>> return event->flag; 
	mov	si, word [bp+4]
	mov	ax, word [si]
L_yakc_111:
	mov	sp, bp
	pop	bp
	ret
L_yakc_107:
	push	bp
	mov	bp, sp
	jmp	L_yakc_108
L_yakc_117:
	DB	"ANY",0
L_yakc_116:
	DB	"ALL",0
	ALIGN	2
YKEventSet:
	; >>>>> Line:	399
	; >>>>> void YKEventSet(YKEVENT *event, unsigned eventMask) { 
	jmp	L_yakc_118
L_yakc_119:
	; >>>>> Line:	401
	; >>>>> event->flag = event->flag |  
	mov	si, word [bp+4]
	mov	ax, word [si]
	or	ax, word [bp+6]
	mov	word [si], ax
	; >>>>> Line:	403
	; >>>>> YKEnterMutex(); 
	call	YKEnterMutex
	; >>>>> Line:	405
	; >>>>> browser = readyRoot; 
	mov	ax, word [readyRoot]
	mov	word [bp-2], ax
	; >>>>> Line:	406
	; >>>>> while(browser){ 
	jmp	L_yakc_121
L_yakc_120:
	; >>>>> Line:	407
	; >>>>> if ((browser->state == 5) && (browser->event == event)) { 
	mov	si, word [bp-2]
	add	si, 2
	cmp	byte [si], 5
	jne	L_yakc_123
	mov	si, word [bp-2]
	add	si, 12
	mov	ax, word [bp+4]
	cmp	ax, word [si]
	jne	L_yakc_123
	; >>>>> Line:	408
	; >>>>> if(browser->mode == 2){ 
	mov	si, word [bp-2]
	add	si, 14
	cmp	word [si], 2
	jne	L_yakc_124
	; >>>>> Line:	409
	; >>>>> if(event->flag == browser->mask){ 
	mov	si, word [bp-2]
	add	si, 16
	mov	di, word [bp+4]
	mov	ax, word [di]
	cmp	ax, word [si]
	jne	L_yakc_125
	; >>>>> Line:	410
	; >>>>> printString("ALL"); 
	mov	ax, L_yakc_116
	push	ax
	call	printString
	add	sp, 2
	; >>>>> Line:	411
	; >>>>> browser->state = 1; 
	mov	si, word [bp-2]
	add	si, 2
	mov	byte [si], 1
	; >>>>> Line:	412
	; >>>>> browser->event = 0; 
	mov	si, word [bp-2]
	add	si, 12
	mov	word [si], 0
	; >>>>> Line:	413
	; >>>>> browser->mask = 0; 
	mov	si, word [bp-2]
	add	si, 16
	mov	word [si], 0
	; >>>>> Line:	414
	; >>>>> browser->mode = 0; 
	mov	si, word [bp-2]
	add	si, 14
	mov	word [si], 0
L_yakc_125:
	jmp	L_yakc_126
L_yakc_124:
	; >>>>> Line:	417
	; >>>>> else if(browser->mode == 1){ 
	mov	si, word [bp-2]
	add	si, 14
	cmp	word [si], 1
	jne	L_yakc_127
	; >>>>> Line:	418
	; >>>>> nt->flag &  
	mov	si, word [bp-2]
	add	si, 16
	mov	ax, word [si]
	mov	si, word [bp+4]
	and	ax, word [si]
	je	L_yakc_128
	; >>>>> Line:	419
	; >>>>> printString("ANY"); 
	mov	ax, L_yakc_117
	push	ax
	call	printString
	add	sp, 2
	; >>>>> Line:	420
	; >>>>> browser->state = 1; 
	mov	si, word [bp-2]
	add	si, 2
	mov	byte [si], 1
	; >>>>> Line:	421
	; >>>>> browser->event = 0; 
	mov	si, word [bp-2]
	add	si, 12
	mov	word [si], 0
	; >>>>> Line:	422
	; >>>>> browser->mask = 0; 
	mov	si, word [bp-2]
	add	si, 16
	mov	word [si], 0
	; >>>>> Line:	423
	; >>>>> browser->mode = 0; 
	mov	si, word [bp-2]
	add	si, 14
	mov	word [si], 0
L_yakc_128:
L_yakc_127:
L_yakc_126:
L_yakc_123:
	; >>>>> Line:	428
	; >>>>> browser = browser->next; 
	mov	si, word [bp-2]
	add	si, 4
	mov	ax, word [si]
	mov	word [bp-2], ax
	; >>>>> Line:	429
	; >>>>> YKExitMutex(); 
	call	YKExitMutex
L_yakc_121:
	mov	ax, word [bp-2]
	test	ax, ax
	jne	L_yakc_120
L_yakc_122:
	; >>>>> Line:	432
	; >>>>> if(YKISRCallDepth == 0){ 
	mov	ax, word [YKISRCallDepth]
	test	ax, ax
	jne	L_yakc_129
	; >>>>> Line:	433
	; >>>>> YKScheduler(1); 
	mov	al, 1
	push	ax
	call	YKScheduler
	add	sp, 2
L_yakc_129:
	; >>>>> Line:	436
	; >>>>> YKExitMutex(); 
	call	YKExitMutex
	mov	sp, bp
	pop	bp
	ret
L_yakc_118:
	push	bp
	mov	bp, sp
	push	cx
	jmp	L_yakc_119
	ALIGN	2
YKEventReset:
	; >>>>> Line:	439
	; >>>>> void YKEventReset(YKEVENT *event, unsigned eventMask) { 
	jmp	L_yakc_131
L_yakc_132:
	; >>>>> Line:	440
	; >>>>> event->flag = event->flag &  
	mov	ax, word [bp+6]
	not	ax
	mov	si, word [bp+4]
	and	ax, word [si]
	mov	word [si], ax
	mov	sp, bp
	pop	bp
	ret
L_yakc_131:
	push	bp
	mov	bp, sp
	jmp	L_yakc_132
	ALIGN	2
YKTCBs:
	TIMES	180 db 0
YKSEMS:
	TIMES	100 db 0
YKQS:
	TIMES	100 db 0
YKEvents:
	TIMES	100 db 0
readyRoot:
	TIMES	2 db 0
taskToRun:
	TIMES	2 db 0
YKIdleTasks:
	TIMES	512 db 0
